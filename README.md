# Выполнение 9 домашнего задания

В этом задании нам нужно было поработать с многопоточностью в Java и Kotlin. Я создал две папки:

- **Java_project**: здесь находятся Java проекты (всего их 2).
- **Kotlin_project**: здесь лежит один Kotlin проект.

## Java_project

Первый проект — это проект с 5 домашнего задания, где есть взаимодействие с API KudaGo. В задании нужно было добавить новое взаимодействие с событиями от KudaGo. Необходимо было принимать даты пользователя, сумму и код его денежных средств, чтобы затем выдать отфильтрованные мероприятия, куда пользователь мог бы сходить со своим бюджетом и временными рамками. Для конвертации валют я использовал сервис из 8 дз, где мы работали с API Центрального банка России. Поэтому в папке лежат два проекта.

## Kotlin_project

Здесь находится один проект из 4 домашнего задания. Единственное изменение в этом проекте — добавление распараллеливания запроса и 2 теста.

## Замеры времени выполнения распараллеленных проектов

### Java

**Таблица результатов**

| Количество потоков | 1-й запуск (мс) | 2-й запуск (мс) | 3-й запуск (мс) | 4-й запуск (мс) | 5-й запуск (мс) | Среднее время (мс) |
|-------------------|------------------|------------------|------------------|------------------|------------------|---------------------|
| 1                 | 2113             | 906              | 1079             | 1473             | 1052             | 1194.6              |
| 2                 | 3008             | 1256             | 1946             | 1008             | 1644             | 1574.4              |
| 4                 | 2175             | 1854             | 1183             | 1044             | 1529             | 1557                |
| 8                 | 1875             | 1900             | 1231             | 1465             | 1082             | 1512.6              |
| 10                | 2759             | 1327             | 943              | 1058             | 1239             | 1395.2              |

Как мы видим, с одним потоком время наивысшее, так как задачи выполняются последовательно. В двух потоках наблюдаются разные результаты из-за накладных расходов на управление потоками. С четырьмя потоками время выполнения становится более стабильным, поскольку система начинает эффективно использовать ресурсы. При восьми потоках время выполнения остается стабильным, но без значительного улучшения, а при десяти потоках увеличилось из-за накладных расходов или блокировок. 

В общем, я думаю, что основная причина замедления работы потоков — это переключение этих самых потоков.

### Kotlin

**Таблица результатов**

| Кол-во воркеров | Кол-во потоков | Замеры (в миллисекундах)              | Среднее время (в миллисекундах) |
|-----------------|----------------|----------------------------------------|-----------------------------------|
| 1               | 1              | 2985, 2203, 2334, 2438, 2475          | 2487                              |
| 2               | 4              | 1833, 1833, 2505, 1720, 2040          | 1986                              |
| 5               | 8              | 2704, 3186, 2767, 2900, 2723          | 2856                              |
| 10              | 16             | 3285, 3648, 2980, 3461, 3084          | 3292                              |
| 20              | 32             | 3443, 3806, 3501, 3581, 3649          | 3596                              |

При увеличении количества воркеров и потоков общее время инициализации возрастает. Однако в случае с 2 воркерами и 4 потоками есть улучшение по сравнению с 1 воркером и 1 потоком.

Я считаю, что второй кейс (2 воркера, 4 потока) оказался самым эффективным, потому что программа распараллелена на два метода, и такой паттерн позволяет более эффективно распределять задачи между потоками. Также, я думаю, что соблюдается некий баланс, поэтому нет накладных расходов в производительности.
